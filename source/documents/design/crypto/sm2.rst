.. _sm2:

==============
国密sm2算法
==============

概述
========

SM2算法是中华人民共和国政府采用的一种公钥加密标准，由国家密码管理局于2010年12月17日发布。在商用密码体系中，SM2用于替换RSA算法，可用来实现非对称加密、数字签名、密钥交换等功能。作为一种基于椭圆曲线的公钥密码算法，SM2算法在相同安全程度下，较RSA算法在密钥规模上存在优势。

======== ========== ============
\        SM2        RSA
======== ========== ============
密钥规模 192-256bit 2048-4096bit
======== ========== ============

算法标准包括4个部分：


   1） 总则，适用于基域为素域和二元扩域的椭圆曲线公钥密码算法；

   2） 数字签名算法，适用于商用密码应用中的数字签名和验证，可满足多种密码应用中的身份认证和数据完整性、真实性的安全需求；

   3） 密钥交换协议，适用于商用密码应用中的密钥交换，可满足通信双方经过两次或可选三次信息传递过程，计算获取一个由双方共同决定的共享秘密密钥（会话密钥）；

   4） 公钥加密算法，适用于商用密码应用中的消息加解密，消息发送者可以利用接收者的公钥对消息进行加密，接收者用对应的私钥进行解密；

相关标准为“GM/T 0003.1-2012 SM2椭圆曲线公钥密码算法第1部分：总则”，
“GM/T 0003.2-2012 SM2椭圆曲线公钥密码算法第2部分：数字签名算法”，
“GM/T 0003.3-2012 SM2椭圆曲线公钥密码算法第3部分：密钥交换协议”，
“GM/T 0003.4-2012 SM2椭圆曲线公钥密码算法第4部分：公钥加密算法”，
“GM/T 0003.5-2012 SM2椭圆曲线公钥密码算法第5部分：参数定义”。

签名算法
===========

数字签名是附加在数据单元上的一些数据，或是对数据单元所作密码变换的结果，当正常应用时提供如下服务：

-  数据来源的确认；

-  数据完整性的验证；

-  签名者不可抵赖的保证。

数字签名算法由一个签名者对数据产生数字签名，并由一个验证者验证签名的可靠性。每个签名者有一个公钥和一个私钥，其中私钥用于产生签名，验证者用签名者的公钥验证签名。

在签名的生成过程之前，要用密码杂凑函数（哈希函数）对消息M (包含 :math:`Z_A` 和待签消息M)进行压缩。

同理，在验证过程之前，要用密码杂凑函数对 :math:`M ′` (包含 :math:`Z_A` 和验证消息 :math:`M′` )进行压缩。

系统参数
^^^^^^^^^^^^

椭圆曲线的系统参数为：

-  :math:`F_q` ：包含 :math:`q` 个元素的素域

-  椭圆曲线方程的参数a、b

-  :math:`G` ：椭圆曲线的基点（ :math:`G=(x_G,y_G)` ）

-  :math:`n` ：基点G的阶，由基点 :math:`G` 生成的群的元素的个数

-  可选项 ：n的余因子 :math:`h` （ :math:`h = |E(F_q)|/n` ）

除了定义了椭圆曲线的参数和签名算法所需要的辅助函数：哈希函数和随机数发生器外，标准引入了用户信息标识的概念。

签名者拥有长度为 :math:`entlen_A` 比特的可辨别标识 :math:`ID_A` ，在标准规定的签名算法中，需要在生成签名和验证签名前计算用户A的哈希值 :math:`Z_A` 。 :math:`Z_A=H_{256}(ENTL_A||ID_A|| a||b||x_G||y_G||x_A||y_A)` ，其中 :math:`ENTL_A` 是由 :math:`entl_A` 转换而成的两个字节。

签名生成
^^^^^^^^^^

1） 预处理

   计算 :math:`Z_A` :  :math:`Z_A=H_{256}(ENTL_A||ID_A|| a||b||x_G||y_G||x_A||y_A)`

2） 签名

   输入：M， :math:`Z_A` ，私钥\ :math:`d_A`

   输出：签名对 :math:`(r,s)`

   A1：消息处理:  :math:`\overline M= Z_A||M`

   A2：计算 :math:`e=H_v(\overline M)`

   A3：产生随机数 :math:`k\in [1,n-1]`

   A4：计算曲线点 :math:`(x_1, y_1)=kG`

   A5：计算 :math:`r= (e+x_1)\ mod\  n` ，若 :math:`r=0` 或 :math:`r+k=n` 则返回A3

   A6：计算 :math:`s= ((1+d_A)^{-1} (k- r*d_A))\ mod\ n` ，若 :math:`s=0` 则返回A3

   A7：输出签名对 :math:`(r,s)`

签名验证
^^^^^^^^^^

1） 预处理

   计算 :math:`Z_A` ： :math:`Z_A=H_{256}(ENTL_A||ID_A|| a||b||x_G||y_G||x_A||y_A)`

2） 验证

   输入：消息 :math:`M'` ，签名 :math:`(r^{'}, s^{'})` ，公钥 :math:`P_A`

   输出：1 or 0

   B1：检验 :math:`r′ ∈[1,n-1]` 是否成立，若不成立则验证不通过；

   B2：检验 :math:`s′ ∈[1,n-1]`\ 是否成立，若不成立则验证不通过；

   B3：消息处理:  :math:`\overline M^{'}= Z_A||M`

   B4：计算 :math:`e'=H_v(\overline M^{'})`

   B5：计算 :math:`t = (r'+ s')\ mod\ n`

   B6：计算椭圆曲线点 :math:`(x_1',y_1') = s'G+ tP_A`

   B7：计算 :math:`R=(e'+x_1')\ mod\ n` ，检验 :math:`R=r'` 是否成立，若成立则验证通过；否则验证不通过

正确性说明
^^^^^^^^^^^^

展开步骤B6中的等式

.. math::


   \begin{align}
    s'G+ tP_A &= (s'+ (r'+s')d_A)G \\
    &= s'(1 + d_A)G + r'd_AG
    \end{align}

根据签名生成中A6步骤的等式，可得

.. math::


   k = s(1+d_A)+ rd_A 

因此，步骤B6中的等式可以恢复出签名生成的曲线点 :math:`kG`

密钥交换
=============

密钥交换协议是两个用户A和B通过交互的信息传递，用各自的私钥和对方的公钥来商定一个只有他们知道的秘密密钥。这个共享的秘密密钥通常用在某个对称密码算法中。该密钥交换协议能够用于密钥管理和协商。

密钥交换流程
^^^^^^^^^^^^^^

用户A和B双方为了生成相同的会话密钥，需要进行如下交互： 

记 :math:`w=⌈(⌈log_2(n)⌉/2)⌉−1`

用户A： 

A1：产生随机数 :math:`r_A ∈ [1, n-1]` ；

A2：计算椭圆曲线点 :math:`R_A = [r_A]G=(x_1,y_1)` ；

A3：将 :math:`R_A` 发送给用户B；

用户B： 

B1：产生随机数 :math:`r_B ∈ [1, n-1]` ；

B2：计算椭圆曲线点 :math:`R_B = [r_B]G=(x_2,y_2)` ；

B3：计算 :math:`\overline x_2 = 2^w + (x_2\&(2^w −1))` ；

B4：计算 :math:`t_B = (d_B +\overline x_2 ·r_B)\mod\ n` ；

B5：验证RA是否满足椭圆曲线方程，若不满足则协商失败；否则计算 :math:`\overline x_1 = 2^w + (x_1\&(2^w −1))`

B6：计算椭圆曲线点 :math:`V = [h ·t_B](P_A +[\overline x_1]R_A) = (x_V ,y_V )` ，若V是无穷远点，则B协商失败；

B7：计算 :math:`K_B=KDF(x_V ∥ y_V ∥ Z_A ∥ Z_B,klen)` ；

B8：将 :math:`R_B` 发送给用户A；

用户A： 

A4：计算 :math:`\overline x_1 = 2^w + (x_1\&(2^w −1))`

A5：计算 :math:`t_A = (d_A +\overline x_1 ·r_A)\mod\ n` ；

A6：验证 :math:`R_B` 是否满足椭圆曲线方程，若不满足则协商失败；否则计算 :math:`\overline x_2 = 2^w + (x_2\&(2^w −1))`

A7：计算椭圆曲线点 :math:`U = [h ·t_A](P_B+[\overline x_2]R_B) = (x_U ,y_U )`，若U是无穷远点，则A协商失败；

A8：计算 :math:`K_A=KDF(x_U ∥ y_U ∥ Z_A ∥ Z_B,klen)` ；

PS：上述步骤省略了校验步骤。

正确性说明：

将步骤B6和步骤A7中生成的椭圆曲线点U和V分别展开，可得： 

.. math::


   (x_V,y_V) = h( (d_B +\overline x_2 ·r_B))(d_A +\overline x_1 ·r_A)G

.. math::


    (x_U,y_U) = h( (d_A +\overline x_1 ·r_A))(d_B +\overline x_2 ·r_B)G

公钥加密
===============

公钥加密算法规定发送者用接收者的公钥将消息加密成密文，接收者用自已的私钥对收到的密文进行解密还原成原始消息。

辅助函数
^^^^^^^^^^^^

============= ===============================
:math:`klen`  要获得的密钥数据的比特长度
============= ===============================
参数          定义
:math:`H_v()` 其输出是长度恰为v比特的哈希函数
:math:`ct`    32比特构成的计数器
============= ===============================

辅助函数：

1） 哈希函数：使用国家密码管理局批准的密码杂凑算法，如SM3密码杂凑算法

2） :math:`KDF(Z, klen)` ：

   1) 初始化计数器 :math:`ct = 0x000000001`
   2) 对i从1到 :math:`\lceil klen/v \rceil` 执行：

      1) 计算 :math:`H_{a_i} = H_v(Z|| ct)`
      2) ct ++
         //之所以要计数器++，是为了满足最终KDF的输出是均匀随机的，如果不加的话，则每次hash输出的都是同一个值。
      3) 若  :math:`klen/v`\ 是整数，
         则  :math:`H_{a!_{\lceil klen/v \rceil}} = H_{a_{\lceil klen/v \rceil}}` ，
         否则  :math:`H_{a!_{\lceil klen/v \rceil}}` 为 \ :math:`H_{a_{\lceil klen/v \rceil}}` 最左边的 :math:`(klen - (v \times \lfloor klen/v \rfloor))` 比特

   3) :math:`K = H_{a_1} || H_{a_2}||...||H_{a_{\lceil klen/v \rceil-1}} || H_a!_{\lceil klen/v \rceil}`

加密流程
^^^^^^^^^^^^

输入： 消息M， :math:`klen` 为消息的长度，公钥 :math:`P_B`

输出： 临时公钥(:math:`C_1`)、密文（ :math:`C_2` ）、消息认证码（ :math:`C_3` ）

A1：产生随机数 :math:`k∈[1,n-1]` ；

A2：计算椭圆曲线点 :math:`C_1=[k]G=(x_1,y_1)`

A3：计算椭圆曲线点 :math:`S=[h]P_B` ，若S是无穷远点，则报错并退出；

A4：计算椭圆曲线点 :math:`[k]P_B=(x_2,y_2)` //
A与B共同持有的密钥，因为A知道B的公钥 :math:`P_B` ，然后B是知道 :math:`C_1=kG` ，B可以利用自己的私钥 :math:`d_B` 与 :math:`C_1` 计算出 :math:`kP_B` 。

A5：计算 :math:`t=KDF(x_2 ∥ y_2, klen)` ，若t为全0比特串，则返回A1；

A6：计算 :math:`C_2 = M ⊕ t` ；//t不能全为0，如果全为0，则C_2=M

A7：计算 :math:`C_3 = Hash(x_2 ∥ M ∥ y_2)` ； :math:`C_3` 验证消息的完整性，以及验证的确是A发出来的。

A8：输出密文 :math:`C = C_1 ∥ C_2 ∥ C_3` 。

解密流程
^^^^^^^^^^^

输入：密文 :math:`C = C_1 ∥ C_2 ∥ C_3` ，私钥\ :math:`d_B`

输出：明文 :math:`M'` 或fail

B1：验证 :math:`C_1` 是否满足椭圆曲线方程，若不满足则报错并退出；

B2：计算椭圆曲线点 :math:`S=[h]C_1` ，若S是无穷远点，则报错并退出；

B3：计算 :math:`[d_B]C_1=(x_2,y_2)`

B4：计算 :math:`t=KDF(x_2 ∥ y_2, klen)` ，若t为全0比特串，则报错并退出；

B5：计算 :math:`M′ = C_2 ⊕ t` ；

B6：计算 :math:`u = Hash(x_2 ∥ M′ ∥ y_2)` ，检验 :math:`u = C_3` ，若检验失败则报错并退出；

B7：输出明文 :math:`M'`